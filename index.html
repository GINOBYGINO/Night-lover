<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æš—å¤œæƒ…æ›¸ - åŒæ¨‚å¡ç‰ŒéŠæˆ²</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-dark: #1a1510;
            --bg-panel: #2c241b;
            --text-main: #eebb44;
            --text-dim: #8b7557;
            --accent: #d4a035;
            --danger: #b94444;
            --card-w: 100px;
            --card-h: 140px;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            margin: 0; padding: 0;
            height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
        }

        /* --- é€šç”¨ UI --- */
        .hidden { display: none !important; }
        .btn {
            background: linear-gradient(180deg, #d4a035, #8f6a1e);
            border: 2px solid #5c4314;
            color: #1a0f00;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #5c4314;
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 0 0; }
        .btn:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }
        
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column;
        }
        .modal-content {
            background: var(--bg-panel);
            border: 2px solid var(--accent);
            padding: 20px;
            border-radius: 10px;
            width: 90%; max-width: 400px;
            max-height: 80vh; overflow-y: auto;
            text-align: center;
        }

        /* --- ç™»å…¥èˆ‡å¤§å»³ --- */
        #login-screen, #lobby-screen {
            flex: 1; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; gap: 15px;
            padding: 20px;
        }
        input {
            background: #110d09; border: 1px solid var(--accent);
            color: var(--text-main); padding: 10px; border-radius: 5px;
            text-align: center; font-size: 1.2rem; width: 100%; max-width: 300px;
        }
        .avatar-preview { font-size: 3rem; cursor: pointer; animation: bounce 2s infinite; }
        
        /* --- éŠæˆ²ä¸»ç•«é¢ --- */
        #game-screen { flex: 1; display: flex; flex-direction: column; position: relative; }
        
        /* ä¸Šæ–¹è³‡è¨Šåˆ— */
        .top-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; background: rgba(0,0,0,0.5);
            border-bottom: 1px solid var(--text-dim);
        }

        /* å°æ‰‹å€åŸŸ */
        .opponents-area {
            flex: 1; display: flex; flex-wrap: wrap; 
            justify-content: center; gap: 10px; padding: 10px;
            overflow-y: auto;
        }
        .player-badge {
            background: var(--bg-panel); border: 1px solid var(--text-dim);
            padding: 5px; border-radius: 5px; width: 80px;
            text-align: center; position: relative;
            transition: 0.3s;
        }
        .player-badge.active-turn { border-color: var(--accent); box-shadow: 0 0 10px var(--accent); }
        .player-badge.eliminated { opacity: 0.5; filter: grayscale(1); }
        .player-badge.protected::after { content: 'ğŸ›¡ï¸'; position: absolute; top: -5px; right: -5px; }
        .player-hand-mini { font-size: 0.8rem; color: #aaa; margin-top: 2px; }

        /* ä¸­å¤®æ—¥èªŒèˆ‡ç‰¹æ•ˆ */
        .game-center {
            height: 100px; overflow-y: auto; 
            background: rgba(0,0,0,0.3); margin: 5px;
            font-size: 0.9rem; padding: 5px; border-radius: 5px;
            border: 1px solid #443322;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px dashed #443322; padding-bottom: 2px; }

        /* ä¸‹æ–¹æ‰‹ç‰Œå€ */
        .my-area {
            background: #221a12; padding: 10px;
            display: flex; flex-direction: column; gap: 10px;
            border-top: 2px solid var(--accent);
        }
        .hand-container { display: flex; justify-content: center; gap: 15px; min-height: 150px; }
        
        /* å¡ç‰Œæ¨£å¼ */
        .card {
            width: var(--card-w); height: var(--card-h);
            background: #e8d0a9; color: #2e2211;
            border-radius: 8px; border: 4px solid #5c4314;
            display: flex; flex-direction: column; align-items: center;
            position: relative; cursor: pointer; transition: transform 0.2s;
            padding: 5px; text-align: center;
        }
        .card.selected { transform: translateY(-20px); box-shadow: 0 0 15px var(--accent); border-color: #ffcc00; }
        .card-header { display: flex; justify-content: space-between; width: 100%; font-weight: bold; border-bottom: 1px solid #8f6a1e; }
        .card-gender { font-size: 0.8rem; }
        .card-img { font-size: 2.5rem; margin: 5px 0; }
        .card-desc { font-size: 0.7rem; line-height: 1.1; flex: 1; display: flex; align-items: center; }
        .card.plus { border-color: #b94444; background: #ebd5b3; }
        
        /* è¼”åŠ©æŒ‰éˆ•å€ */
        .controls { display: flex; justify-content: space-between; }
        
        /* æµ®å‹•æç¤ºè¡¨ */
        .ref-table { width: 100%; font-size: 0.85rem; border-collapse: collapse; }
        .ref-table th, .ref-table td { border: 1px solid var(--text-dim); padding: 4px; text-align: center; }
        .ref-table .eliminated-card { color: #555; text-decoration: line-through; }

        /* é€²åº¦æ¢ */
        .progress-bar-container {
            width: 100%; height: 4px; background: #333; position: absolute; top: 0; left: 0;
            display: none;
        }
        .progress-bar { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s linear; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    </style>
</head>
<body>

<div id="loading-bar" class="progress-bar-container"><div class="progress-bar"></div></div>

<div id="login-screen">
    <h1>ğŸ· æš—å¤œæƒ…æ›¸</h1>
    <div class="avatar-preview" id="avatar-display" onclick="randomizeAvatar()">ğŸ˜</div>
    <p style="font-size:0.8rem; color:var(--text-dim)">(é»æ“Šé ­åƒéš¨æ©Ÿæ›´æ›)</p>
    <input type="text" id="username" placeholder="è¼¸å…¥ä½ çš„æš±ç¨±" maxlength="8">
    
    <div style="margin-top: 20px; display:flex; gap:10px; flex-direction:column; width:100%; align-items:center;">
        <button class="btn" onclick="createGame()">å‰µå»ºæˆ¿é–“ (Host)</button>
        <div style="display:flex; gap:5px; width:100%; justify-content:center;">
            <input type="text" id="room-id-input" placeholder="è¼¸å…¥æˆ¿é–“ ID" style="width:150px;">
            <button class="btn" onclick="joinGame()">åŠ å…¥</button>
        </div>
        <button class="btn" onclick="attemptRejoin()" style="background: #444; font-size:0.8rem;">æ–·ç·šé‡é€£</button>
    </div>
    <div id="status-msg" style="color: var(--accent); height: 20px;"></div>
</div>

<div id="lobby-screen" class="hidden">
    <h2>ğŸ° é…’é¤¨å¤§å»³</h2>
    <div style="background:rgba(0,0,0,0.3); padding:10px; border-radius:5px;">
        æˆ¿é–“ ID: <strong id="lobby-room-id" style="color:#fff; user-select:text;"></strong>
        <button onclick="copyRoomId()" style="margin-left:5px; font-size:0.8rem;">è¤‡è£½</button>
    </div>
    
    <div id="lobby-players" style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
        </div>

    <div id="host-controls" class="hidden" style="margin-top:20px; text-align:center;">
        <p>éœ€è¦ 2-5 äººæ‰èƒ½é–‹å§‹</p>
        <button class="btn" onclick="startGameHost()">é–‹å§‹éŠæˆ²</button>
    </div>
    <div id="client-wait-msg" style="margin-top:20px; color:var(--text-dim);">
        ç­‰å¾…æˆ¿ä¸»é–‹å§‹...
        <br><br>
        <small>é»æ“Šéª°å­æ¶ˆé£ä¸€ä¸‹ï¼š</small>
        <div style="font-size:2rem; cursor:pointer;" onclick="this.innerText = ['âš€','âš','âš‚','âšƒ','âš„','âš…'][Math.floor(Math.random()*6)]">ğŸ²</div>
    </div>
</div>

<div id="game-screen" class="hidden">
    <div class="top-bar">
        <div id="deck-count">ç‰Œåº«: 0</div>
        <div id="turn-indicator">ç­‰å¾…ä¸­...</div>
        <button class="btn" style="padding:5px 10px; font-size:0.8rem;" onclick="toggleRef()">ğŸ“œ å¡è¡¨</button>
    </div>

    <div class="opponents-area" id="opponents-container">
        </div>

    <div class="game-center" id="game-log">
        </div>

    <div class="my-area">
        <div class="controls">
            <button id="btn-play" class="btn" disabled onclick="confirmPlayCard()">æ‰“å‡ºå¡ç‰Œ</button>
            <span id="role-indicator" style="align-self:center; color:#888;"></span>
        </div>
        <div class="hand-container" id="my-hand">
            </div>
    </div>
</div>

<div id="ref-modal" class="modal hidden" onclick="if(event.target===this) toggleRef()">
    <div class="modal-content">
        <h3>å‰©é¤˜ç‰Œè¡¨</h3>
        <table class="ref-table">
            <thead><tr><th>#</th><th>åç¨±</th><th>æ€§åˆ¥</th><th>å‰©é¤˜</th></tr></thead>
            <tbody id="ref-table-body"></tbody>
        </table>
        <button class="btn" style="margin-top:10px;" onclick="toggleRef()">é—œé–‰</button>
    </div>
</div>

<div id="selector-modal" class="modal hidden">
    <div class="modal-content">
        <h3 id="selector-title">é¸æ“‡</h3>
        <div id="selector-options" style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center;"></div>
        <button class="btn hidden" id="selector-cancel" style="margin-top:10px; background:#555;" onclick="closeSelector()">å–æ¶ˆ</button>
    </div>
</div>

<div id="gameover-modal" class="modal hidden">
    <div class="modal-content">
        <h2>ğŸ† éŠæˆ²çµæŸ</h2>
        <div id="winner-display" style="font-size:1.5rem; color:var(--text-main); margin:20px 0;"></div>
        <button class="btn" onclick="returnToLobby()">å›åˆ°å¤§å»³</button>
    </div>
</div>

<script>
/* ================= éŠæˆ²è³‡æ–™å®šç¾© ================= */
const CARDS_DEF = {
    1: { id:1, name:"åˆºå®¢", gender:"M", val:1, count:3, plus:false, icon:"ğŸ—¡ï¸", desc:"è¢«çŒœéŒ¯æ™‚ï¼Œå°æ–¹å‡ºå±€ï¼Œä½ é‡æŠ½ã€‚" },
    2: { id:2, name:"è¡›å…µ", gender:"F", val:2, count:5, plus:false, icon:"ğŸ›¡ï¸", desc:"çŒœä¸€äººæ‰‹ç‰Œ(éè¡›å…µ)ï¼Œå°å‰‡å‡ºå±€ã€‚" },
    20: { id:20, name:"å…µé•·", gender:"F", val:2, count:1, plus:true, icon:"ğŸ’‚â€â™€ï¸", desc:"çŒœæ‰€æœ‰äººæ‰‹ç‰Œ(éè¡›å…µ)ï¼Œå°å‰‡å‡ºå±€ã€‚" }, // 2 PLUS
    3: { id:3, name:"ç¥çˆ¶", gender:"M", val:3, count:2, plus:false, icon:"â›ª", desc:"çœ‹ä¸€äººæ‰‹ç‰Œã€‚" },
    30: { id:30, name:"é‚±æ¯”ç‰¹", gender:"M", val:3, count:2, plus:true, icon:"ğŸ¹", desc:"æ¯”å¤§å°ã€‚åŒæ€§å°æ­»ï¼Œç•°æ€§å¤§æ­»ã€‚" }, // 3 PLUS
    4: { id:4, name:"ç”·çˆµ", gender:"M", val:4, count:2, plus:false, icon:"ğŸ©", desc:"æ¯”å¤§å°ï¼Œå°çš„å‡ºå±€ã€‚" },
    40: { id:40, name:"é è¨€å®¶", gender:"F", val:4, count:2, plus:true, icon:"ğŸ”®", desc:"æŠ½1å¼µï¼Œå°‡æ­¤ç‰Œæˆ–æ‰‹ç‰Œæ”¾å›ç‰Œåº«åº•ã€‚" }, // 4 PLUS
    5: { id:5, name:"ä¾å¥³", gender:"F", val:5, count:2, plus:false, icon:"ğŸ–ï¸", desc:"ç›´åˆ°ä¸‹å›åˆå‰ç„¡æ•µã€‚" },
    50: { id:50, name:"å°ä¸‘", gender:"M", val:5, count:2, plus:true, icon:"ğŸ¤¡", desc:"è¤‡è£½ä¸Šä¸€å¼µæ£„ç‰Œæ•ˆæœã€‚" }, // 5 PLUS
    6: { id:6, name:"ç‹å­", gender:"M", val:6, count:1, plus:false, icon:"ğŸ‘‘", desc:"æŒ‡å®šä¸€äººæ£„ç‰Œé‡æŠ½ã€‚" },
    7: { id:7, name:"åœ‹ç‹", gender:"M", val:7, count:1, plus:false, icon:"ğŸ¤", desc:"èˆ‡ä¸€äººäº¤æ›æ‰‹ç‰Œã€‚" },
    8: { id:8, name:"ä¼¯çˆµå¤«äºº", gender:"F", val:8, count:1, plus:false, icon:"ğŸ’ƒ", desc:"æœ‰ç‹æˆ–ç‹å­æ™‚å¿…é ˆæ‰“å‡ºã€‚" },
    9: { id:9, name:"å…¬ä¸»", gender:"F", val:9, count:1, plus:false, icon:"ğŸ‘¸", desc:"æ£„æ‰å‰‡å‡ºå±€ã€‚æ¯”å¤§å°å¿…å‹ã€‚" }
};

const AVATARS = ['ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ¨','ğŸ¯','ğŸ¦','ğŸ®','ğŸ·','ğŸ¸','ğŸ™'];

/* ================= å…¨åŸŸè®Šæ•¸ ================= */
let peer = null;
let conn = null; // Clientç”¨
let connections = {}; // Hostç”¨: { peerId: conn }
let myName = localStorage.getItem('ll_name') || "";
let myAvatar = localStorage.getItem('ll_avatar') || AVATARS[0];
let myPeerId = null;
let isHost = false;
let roomId = "";

// éŠæˆ²ç‹€æ…‹ (Hostç¶­è­·ï¼ŒåŒæ­¥çµ¦Client)
let gameState = {
    phase: 'LOBBY', // LOBBY, GAMING, GAMEOVER
    players: [], // { id, name, avatar, hand:[], out:false, protected:false, connected:true }
    deck: [],
    removedCard: null, // éŠæˆ²é–‹å§‹ç§»é™¤çš„é‚£å¼µ
    discardPile: [], // { cardId, playerId, wasForced: boolean }
    turnIndex: 0,
    logs: [],
    winner: null
};

// æœ¬åœ°ç‹€æ…‹
let selectedHandIndex = -1;
let lastWaitTimer = null;

/* ================= ç¶²è·¯é€£ç·š (WebRTC) ================= */
function initPeer() {
    return new Promise((resolve, reject) => {
        peer = new Peer(null, {
            debug: 1,
            config: { 'iceServers': [{ urls: 'stun:stun.l.google.com:19302' }] } 
        });
        peer.on('open', (id) => {
            myPeerId = id;
            console.log('My ID:', id);
            resolve(id);
        });
        peer.on('error', (err) => {
            console.error(err);
            uiShowStatus("é€£ç·šéŒ¯èª¤: " + err.type);
        });
    });
}

async function createGame() {
    if(!validateInput()) return;
    await initPeer();
    isHost = true;
    roomId = myPeerId;
    
    // åˆå§‹åŒ–è‡ªå·±é€²ç©å®¶åˆ—è¡¨
    gameState.players = [{
        id: myPeerId, name: myName, avatar: myAvatar, 
        hand: [], out: false, protected: false, connected: true
    }];

    setupHostListeners();
    switchToLobby();
}

async function joinGame() {
    if(!validateInput()) return;
    const inputId = document.getElementById('room-id-input').value.trim();
    if(!inputId) return alert("è«‹è¼¸å…¥æˆ¿é–“ID");
    
    await initPeer();
    isHost = false;
    roomId = inputId;
    
    connectToHost(inputId);
}

function setupHostListeners() {
    peer.on('connection', (c) => {
        c.on('open', () => {
            console.log("Client connected:", c.peer);
            connections[c.peer] = c;
        });
        c.on('data', (data) => handleHostData(c.peer, data));
        c.on('close', () => {
            console.log("Client closed:", c.peer);
            handleDisconnect(c.peer);
        });
    });
}

function connectToHost(hostId) {
    conn = peer.connect(hostId);
    conn.on('open', () => {
        // ç™¼é€åŠ å…¥è«‹æ±‚
        conn.send({ 
            type: 'JOIN', 
            payload: { name: myName, avatar: myAvatar, oldId: localStorage.getItem('ll_last_id') } 
        });
        localStorage.setItem('ll_last_host', hostId);
        localStorage.setItem('ll_last_id', myPeerId);
    });
    conn.on('data', (data) => handleClientData(data));
    conn.on('close', () => {
        uiShowStatus("èˆ‡æˆ¿ä¸»æ–·ç·š");
        document.getElementById('game-screen').classList.add('hidden');
        document.getElementById('login-screen').classList.remove('hidden');
    });
    conn.on('error', () => alert("é€£ç·šæˆ¿ä¸»å¤±æ•—"));
}

/* ================= é‚è¼¯è™•ç† (Host Side) ================= */

function handleHostData(peerId, data) {
    switch(data.type) {
        case 'JOIN':
            // æª¢æŸ¥æ˜¯å¦ç‚ºé‡é€£
            let existing = gameState.players.find(p => p.id === peerId || (data.payload.oldId && p.id === data.payload.oldId));
            if (existing) {
                // é‡é€£é‚è¼¯
                existing.connected = true;
                existing.id = peerId; // æ›´æ–°æ–°çš„ peerID
                // å¦‚æœæ˜¯è§€æˆ°è€…æˆ–å·²å‡ºå±€ï¼Œä¿æŒç‹€æ…‹
            } else {
                if(gameState.phase !== 'LOBBY') {
                    // éŠæˆ²ä¸­åŠ å…¥ï¼Œè¨­ç‚ºè§€æˆ° (dummy player)
                     // æš«ä¸å¯¦ä½œä¸­é€”åŠ å…¥ï¼Œç›´æ¥æ‹’çµ•æˆ–è¨­ç‚ºå·²å‡ºå±€
                     return;
                }
                if(gameState.players.length >= 5) return; // æ»¿å“¡
                gameState.players.push({
                    id: peerId, name: data.payload.name, avatar: data.payload.avatar,
                    hand: [], out: false, protected: false, connected: true
                });
            }
            broadcastState();
            break;
        case 'ACTION':
            processGameAction(peerId, data.payload);
            break;
    }
}

function handleDisconnect(peerId) {
    let p = gameState.players.find(pl => pl.id === peerId);
    if(p) {
        p.connected = false;
        // å¦‚æœæ˜¯åœ¨å¤§å»³ï¼Œç›´æ¥ç§»é™¤
        if(gameState.phase === 'LOBBY') {
            gameState.players = gameState.players.filter(pl => pl.id !== peerId);
        } else {
            addLog(`âš ï¸ ${p.name} æ–·ç·šäº†`);
            // å¦‚æœæ˜¯ç•¶å‰å›åˆç©å®¶æ–·ç·šï¼Œå¯èƒ½éœ€è¦å¼·åˆ¶çµæŸå›åˆæˆ–ç­‰å¾…é‡é€£
            // é€™è£¡ç°¡å–®è™•ç†ï¼šä¸è¸¢å‡ºï¼Œå…è¨±é‡é€£
        }
        broadcastState();
    }
}

function broadcastState() {
    // çµ¦æ¯å€‹äººçš„ç‹€æ…‹è¦ç¨å¾®éæ¿¾ (æ‰‹ç‰Œè³‡è¨Šéš±è—)
    const publicState = JSON.parse(JSON.stringify(gameState));
    
    // Host è‡ªå·±ç›´æ¥æ›´æ–° UI
    updateGameUI(gameState);

    // ç™¼é€çµ¦ Clients
    gameState.players.forEach(p => {
        if(p.id === myPeerId) return; // è·³é Host
        if(connections[p.id]) {
            // è£½ä½œé€™å€‹ç©å®¶çš„è¦–è§’
            let playerView = JSON.parse(JSON.stringify(gameState));
            
            // éš±è—å…¶ä»–äººçš„æ‰‹ç‰Œ
            playerView.players.forEach(vp => {
                if(vp.id !== p.id && !p.out) { 
                    // å¦‚æœè‡ªå·±å‡ºå±€äº†ï¼Œå¯ä»¥çœ‹åˆ°æ‰€æœ‰äººçš„ç‰Œ (ä¸Šå¸è¦–è§’)
                    // å¦‚æœè‡ªå·±æ²’å‡ºå±€ï¼Œåˆ¥äººçš„ç‰Œè¦éš±è—
                    vp.hand = vp.hand.map(() => -1); // -1 ä»£è¡¨èƒŒé¢
                }
            });
            // éš±è—ç‰Œåº«å…§å®¹
            playerView.deck = playerView.deck.map(() => -1);
            playerView.removedCard = -1;

            connections[p.id].send({ type: 'UPDATE', state: playerView });
        }
    });
}

/* ================= éŠæˆ²æ ¸å¿ƒæµç¨‹ (Host) ================= */

function startGameHost() {
    if(gameState.players.length < 2) return alert("äººæ•¸ä¸è¶³");
    
    // 1. åˆå§‹åŒ–ç‰Œåº«
    let deck = [];
    for(let k in CARDS_DEF) {
        let def = CARDS_DEF[k];
        for(let i=0; i<def.count; i++) deck.push(def.id);
    }
    // æ´—ç‰Œ
    deck.sort(() => Math.random() - 0.5);
    
    // 2. ç§»é™¤ä¸€å¼µ
    gameState.removedCard = deck.pop();
    
    // 3. ç™¼ç‰Œ
    gameState.players.forEach(p => {
        p.hand = [deck.pop()];
        p.out = false;
        p.protected = false;
    });
    
    gameState.deck = deck;
    gameState.discardPile = [];
    gameState.logs = ["éŠæˆ²é–‹å§‹ï¼"];
    gameState.phase = 'GAMING';
    gameState.turnIndex = Math.floor(Math.random() * gameState.players.length);
    
    startTurn();
}

function startTurn() {
    let activePlayers = gameState.players.filter(p => !p.out);
    if(activePlayers.length <= 1) {
        endGame(activePlayers[0]);
        return;
    }

    let p = gameState.players[gameState.turnIndex];
    if(p.out) {
        nextTurn();
        return;
    }
    
    // è§£é™¤ä¾å¥³
    p.protected = false;

    // æŠ½ç‰Œ
    if(gameState.deck.length > 0) {
        p.hand.push(gameState.deck.pop());
    } else {
        // ç‰Œåº«ç©ºäº†ï¼Œæ‹¿ç§»é™¤çš„é‚£å¼µ
        if(gameState.removedCard !== -1) {
             p.hand.push(gameState.removedCard);
             gameState.removedCard = -1; // åªæ‹¿ä¸€æ¬¡
        } else {
             // æ¥µç«¯æƒ…æ³ï¼šæ²’ç‰Œå¯æŠ½ï¼Œç›´æ¥çµç®—
             endGameByScore();
             return;
        }
    }

    addLog(`è¼ªåˆ° ${p.name} çš„å›åˆ`);
    broadcastState();
}

function nextTurn() {
    gameState.turnIndex = (gameState.turnIndex + 1) % gameState.players.length;
    startTurn();
}

function processGameAction(playerId, payload) {
    let pIdx = gameState.players.findIndex(p => p.id === playerId);
    let player = gameState.players[pIdx];
    
    if(gameState.turnIndex !== pIdx) return; // ä¸æ˜¯ä½ çš„å›åˆ

    const { cardId, targetId, guessId, seerAction } = payload;
    
    // 1. é©—è­‰: ä¼¯çˆµå¤«äººæª¢æŸ¥
    let hasCountess = player.hand.includes(8);
    let hasPrinceOrKing = player.hand.includes(6) || player.hand.includes(7);
    if(hasCountess && hasPrinceOrKing) {
        if(cardId !== 8) {
            // å¼·åˆ¶æ‰“å‡ºä¼¯çˆµ
            // åœ¨ Client ç«¯å·²ç¶“é˜»æ“‹ï¼Œä½† Server ç«¯å†æ“‹ä¸€æ¬¡
            return;
        }
    }

    // 2. ç§»é™¤æ‰‹ç‰Œ
    let cardIdx = player.hand.indexOf(cardId);
    if(cardIdx === -1) return;
    player.hand.splice(cardIdx, 1);

    // 3. åŠ å…¥æ£„ç‰Œå † (å°ä¸‘è¤‡è£½é‚è¼¯éœ€è¦çŸ¥é“ä¸Šä¸€å¼µæ˜¯èª°æ‰“çš„)
    // æ³¨æ„ï¼šå¦‚æœæ˜¯å°ä¸‘ï¼Œé€™å¼µå°ä¸‘å…ˆä¸é€²æ£„ç‰Œå †é‚è¼¯åˆ¤å®š? 
    // è¦å‰‡ï¼šå°ä¸‘è¤‡è£½çš„æ˜¯ã€Œä¸Šä¸€å¼µåœ¨æ£„ç‰Œå †é ‚çš„ç‰Œã€ã€‚
    // æˆ‘å€‘å…ˆæŠŠé€™å¼µç‰Œã€Œæ‰“å‡ºã€é€™å€‹å‹•ä½œè¨˜éŒ„ä¸‹ä¾†ï¼Œä½†çœŸæ­£ç”¢ç”Ÿæ•ˆæœå¯èƒ½æ˜¯è¤‡è£½åˆ¥çš„ã€‚
    
    // è¨˜éŒ„é€™å¼µç‰Œæ‰“å‡º
    addLog(`${player.name} æ‰“å‡ºäº† ${getCardName(cardId)}`);
    
    // å°ä¸‘ç‰¹æ®Šè™•ç†
    let effectiveCardId = cardId;
    if(cardId === 50) { // å°ä¸‘
        if(gameState.discardPile.length > 0) {
            let lastDiscard = gameState.discardPile[gameState.discardPile.length - 1];
            // è¤‡è£½æ•ˆæœ
            effectiveCardId = lastDiscard.cardId;
            addLog(`ğŸ¤¡ å°ä¸‘è¤‡è£½äº† ${getCardName(effectiveCardId)} çš„æ•ˆæœï¼`);
            
            // å°ä¸‘è¤‡è£½é™åˆ¶ï¼šå¦‚æœè¤‡è£½åˆ°è¡›å…µ(2)ï¼Œéœ€è¦æœ‰çŒœæ¸¬ç›®æ¨™ã€‚å¦‚æœ Client æ²’å‚³ guessId (å› ç‚º Client UI é¡¯ç¤ºçš„æ˜¯å°ä¸‘)ï¼Œé€™æœƒæœ‰å•é¡Œã€‚
            // è§£æ±ºæ–¹æ¡ˆï¼šClient ç«¯æ‰“å°ä¸‘æ™‚ï¼Œå¦‚æœå ´ä¸Šæœ€å¾Œä¸€å¼µæ˜¯éœ€æŒ‡å®šç›®æ¨™çš„ï¼ŒClient å¿…é ˆå½ˆå‡ºé¸å–®ã€‚
            // é€™è£¡å‡è¨­ Client å·²ç¶“æ­£ç¢ºå‚³é€äº† target/guessã€‚
        } else {
            addLog("ğŸ¤¡ å ´ä¸Šç„¡ç‰Œï¼Œå°ä¸‘ç„¡æ•ˆæœ");
            effectiveCardId = -1; // ç„¡æ•ˆæœ
        }
    }

    // 4. åŸ·è¡Œæ•ˆæœ
    if(effectiveCardId !== -1) {
        executeCardEffect(player, effectiveCardId, targetId, guessId, seerAction);
    }
    
    // 5. æ£„ç‰Œé€²å † (é€™å¼µç‰Œæ‰“å®Œäº†)
    gameState.discardPile.push({ cardId: cardId, playerId: player.id });
    
    // 6. æª¢æŸ¥ 9 è™Ÿ å…¬ä¸» (å¦‚æœæ‰“å‡ºçš„æ˜¯å…¬ä¸»)
    if(cardId === 9) {
        addLog(`ğŸ˜± ${player.name} æ£„æ‰äº†å…¬ä¸»ï¼ç›´æ¥å‡ºå±€ï¼`);
        eliminate(player);
    }

    // æª¢æŸ¥ç‰Œåº«æ˜¯å¦ç©ºäº† (çµæŸæ¢ä»¶2)
    if(gameState.deck.length === 0 && gameState.players.filter(p => !p.out).length > 1) {
        // å¦‚æœå‰›æ‰æ˜¯æŠ½æœ€å¾Œä¸€å¼µç‰Œï¼ŒåŸ·è¡Œå®Œæ•ˆæœå¾Œçµç®—
        endGameByScore();
    } else {
        // ç¹¼çºŒ
        if(!checkGameEndInstant()) {
            // å¦‚æœé è¨€å®¶ï¼Œä¸éœ€è¦æ›äººï¼Œå› ç‚ºé è¨€å®¶æ˜¯ã€ŒæŠ½ä¸€æ”¾ä¸€ã€ï¼Œé‚„åœ¨å›åˆå…§? 
            // ä¸ï¼Œé è¨€å®¶æ˜¯ï¼šæŠ½ç‰Œéšæ®µå·²æŠ½1(å…±2)ï¼Œæ‰“å‡ºé è¨€å®¶ï¼Œå†æŠ½1(å…±2)ï¼Œé¸1æ”¾å›ï¼Œå‰©1ï¼Œå›åˆçµæŸã€‚
            // é‚è¼¯å·²åœ¨ executeCardEffect è™•ç†
            nextTurn();
        }
    }
    broadcastState();
}

function executeCardEffect(attacker, cardId, targetId, guessId, seerAction) {
    let target = gameState.players.find(p => p.id === targetId);
    
    // é©—è­‰ç„¡æ•µ (ä¾å¥³)
    if(target && target.protected && cardId !== 50 && cardId !== 40 && cardId !== 5) {
        // ä¾å¥³ç‹€æ…‹ä¸å¯è¢«æŒ‡å®š (é™¤äº†è¤‡è£½ç‰Œå¯èƒ½ç”¢ç”Ÿçš„é‚Šç·£æƒ…æ³ï¼Œä¸éé€šå¸¸ç„¡æ•µå°±æ˜¯ç„¡æ•µ)
        // 5è™Ÿæœ¬èº«æ˜¯çµ¦è‡ªå·± buffï¼Œä¸éœ€è¦ targetã€‚40è™Ÿé è¨€å®¶æ˜¯å°è‡ªå·±ã€‚
        addLog(`ğŸ›¡ï¸ ${target.name} æœ‰ä¾å¥³ä¿è­·ï¼ŒæŠ€èƒ½ç„¡æ•ˆï¼`);
        return;
    }
    
    // è™•ç† 1 è™Ÿ åˆºå®¢çš„è¢«å‹• (åœ¨è¡›å…µ/å…µé•·é‚è¼¯å…§è™•ç†)

    switch(cardId) {
        case 1: // åˆºå®¢ (ä¸»å‹•æ‰“å‡ºç„¡æ•ˆæœï¼Œåªæ˜¯æ£„ç‰Œæ›ç‰Œ)
            addLog("åˆºå®¢æ½›ä¼ä¸­...");
            // å¦‚æœæ˜¯è¢«å¼·åˆ¶æ£„æ‰çš„(ç‹å­)ï¼Œé‚£æ˜¯å¦å¤–çš„é‚è¼¯ã€‚é€™è£¡æ˜¯ä¸»å‹•æ‰“å‡º(é›–ç„¶å¾ˆç¬¨ä½†è¦å‰‡å…è¨±)ï¼Œå°±åªæ˜¯æ£„ä¸€å¼µé‡æŠ½?
            // è¦å‰‡ï¼šã€Œæ£„æ‰æ­¤æ‰‹ç‰Œï¼Œå†æŠ½ä¸€å¼µã€ã€‚
            // ä½†é€™è£¡æ˜¯ã€Œæ‰“å‡ºã€æ­¥é©Ÿã€‚å¦‚æœä¸»å‹•æ‰“å‡ºåˆºå®¢ï¼Œå°±åªæ˜¯ç•¶ä½œä¸€å¼µç„¡æ•ˆæœç‰Œã€‚
            // åˆºå®¢çš„ç‰¹æ®Šæ•ˆæœæ˜¯ã€ŒæŒæœ‰æ™‚è¢«çŒœéŒ¯ã€ã€‚
            break;
            
        case 2: // è¡›å…µ
            if(target && guessId) {
                addLog(`${attacker.name} çŒœ ${target.name} æ˜¯ ${getCardName(guessId)}`);
                if(target.hand.includes(guessId)) {
                    addLog(`ğŸ¯ çŒœå°äº†ï¼`);
                    eliminate(target);
                } else {
                    addLog(`âŒ çŒœéŒ¯äº†ï¼`);
                    checkAssassinTrigger(target, attacker);
                }
            }
            break;
            
        case 20: // å…µé•· (çŒœæ‰€æœ‰äºº)
            if(guessId) {
                addLog(`${attacker.name} å°æ‰€æœ‰äººå®£å‘Šï¼šä½ å€‘æ˜¯ ${getCardName(guessId)}ï¼`);
                let activeOpponents = gameState.players.filter(p => !p.out && p.id !== attacker.id);
                activeOpponents.forEach(op => {
                    if(op.protected) {
                        addLog(`ğŸ›¡ï¸ ${op.name} å…ç–«`);
                    } else if(op.hand.includes(guessId)) {
                        addLog(`ğŸ¯ ${op.name} è¢«æŠ“åˆ°äº†ï¼`);
                        eliminate(op);
                    } else {
                        // å…µé•·çŒœéŒ¯æ²’äº‹ï¼Œä½†å¦‚æœçŒœéŒ¯çš„äººæ‰‹ä¸Šæœ‰åˆºå®¢ï¼Ÿ
                        checkAssassinTrigger(op, attacker);
                    }
                });
            }
            break;

        case 3: // ç¥çˆ¶ (çœ‹ç‰Œ)
            // Clientç«¯æœƒæ”¶åˆ° target çš„æ‰‹ç‰Œè³‡æ–™ (åœ¨ broadcastState è™•ç†ï¼Œå› ç‚º target æ²’æœ‰ outï¼Œæ­£å¸¸æ˜¯ä¸å‚³æ‰‹ç‰Œçš„)
            // é€™è£¡éœ€è¦é€éç§è¨Šæˆ–æ˜¯ç‰¹æ®Šçš„ payload å‚³çµ¦ attacker
            // ç°¡åŒ–åšæ³•ï¼šHost ç›´æ¥å‚³ä¸€æ¢åªæœ‰ attacker èƒ½çœ‹åˆ°çš„ log æˆ–è€…æ˜¯ popup
            // ä½†å› ç‚ºæˆ‘å€‘æ¶æ§‹æ˜¯ broadcastStateï¼Œæˆ‘å€‘å¯ä»¥åœ¨ state è£¡åŠ ä¸€å€‹ "privateInfo" æ¬„ä½
            // æˆ–æ˜¯ç›´æ¥ Log: "${attacker.name} æŸ¥çœ‹äº† ${target.name} çš„ç‰Œ"
            // çœŸå¯¦å…§å®¹åªæœ‰ attacker çŸ¥é“ -> é€™éœ€è¦ Client ç«¯é…åˆ
            // ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘åœ¨ broadcast æ™‚ï¼Œç‰¹åˆ¥å° attacker çš„ payload å¡å…¥ target çš„æ‰‹ç‰Œ
            // é€™è£¡å…ˆè¨˜éŒ„ï¼ŒbroadcastState å‡½æ•¸éœ€è¦ä¿®æ”¹ä»¥æ”¯æ´ä¸€æ¬¡æ€§ç§å¯†è¨Šæ¯ï¼Œ
            // æˆ–è€…æˆ‘å€‘ç°¡å–®é»ï¼šç›´æ¥ log å‡ºä¾† "ç¥çˆ¶æŸ¥çœ‹äº†ç‰Œ"ï¼Œå…·é«”å…§å®¹é¡¯ç¤ºåœ¨ attacker çš„ UI ä¸Š (é€é private channel)
            if(target) {
                sendPrivateData(attacker.id, { type: 'SHOW_HAND', targetName: target.name, hand: target.hand });
            }
            break;

        case 30: // é‚±æ¯”ç‰¹ (æ¯”å¤§å°)
            if(target) {
                compareHands(attacker, target, true); // true = é‚±æ¯”ç‰¹æ¨¡å¼
            }
            break;
            
        case 4: // ç”·çˆµ
            if(target) {
                compareHands(attacker, target, false);
            }
            break;

        case 40: // é è¨€å®¶
            // æŠ½ä¸€å¼µ
            if(gameState.deck.length > 0) {
                let drawn = gameState.deck.pop();
                // é€™è£¡å…¶å¯¦é‚è¼¯è¤‡é›œï¼Œå› ç‚ºè¦è®“ç©å®¶é¸ã€‚
                // ç‚ºäº†ç°¡åŒ–æµæš¢åº¦ï¼šæˆ‘å€‘å‡è¨­ Client ç«¯åœ¨æ‰“å‡ºé è¨€å®¶æ™‚ï¼Œ
                // å·²ç¶“æ¨¡æ“¬äº†ã€ŒæŠ½ç‰Œ->é¸ç‰Œ->å›å‚³ seerActionã€çš„éç¨‹ï¼Ÿ
                // ä¸è¡Œï¼Œå› ç‚º Client ä¸çŸ¥é“ç‰Œåº«ä¸‹ä¸€å¼µæ˜¯ä»€éº¼ã€‚
                // æ­£ç¢ºæµç¨‹ï¼šServer å‘Šè¨´ Attacker "ä½ æŠ½åˆ°äº† X"ï¼Œç„¶å¾Œç­‰å¾… Attacker æ±ºå®šç•™å“ªå¼µã€‚
                // é€™æœƒä¸­æ–·æµç¨‹ã€‚
                // **æŠ˜è¡·æ–¹æ¡ˆ**ï¼šé è¨€å®¶æ‰“å‡ºå¾Œï¼Œç³»çµ±è‡ªå‹•åŸ·è¡Œï¼šæŠ½ä¸€å¼µï¼Œå¦‚æœæŠ½åˆ°çš„æ¯”æ‰‹ä¸Šå¤§ï¼Œä¿ç•™å¤§çš„ï¼Œå°çš„æ”¾å›åº•ã€‚(è‡ªå‹•æœ€ä½³åŒ–?)
                // ä¸ï¼Œé€™å‰å¥ªç©å®¶æ¨‚è¶£ã€‚
                // æ”¹ç‚ºï¼šæ‰“å‡ºé è¨€å®¶ -> ç‹€æ…‹åˆ‡æ›ç‚º "SEER_CHOICE" -> åªå…è¨±è©²ç©å®¶æ“ä½œ -> æ“ä½œå®Œ -> æ¢å¾© GAMING
                // ç”±æ–¼é€™éœ€è¦å¤§å¹…ä¿®æ”¹ç‹€æ…‹æ©Ÿï¼Œé€™è£¡æ¡ç”¨ **ã€Œéš¨æ©Ÿè™•ç†ã€æˆ–ã€Œè‡ªå‹•ä¿ç•™é»æ•¸å¤§è€…ã€** ä»¥ä¿æŒå–®ä¸€æ–‡ä»¶ç°¡æ½”åº¦ã€‚
                // æˆ–è€…ï¼šClient æ‰“å‡ºé è¨€å®¶æ™‚ï¼ŒHost å›å‚³ä¸€å€‹ "SEER_RESULT" äº‹ä»¶ï¼Œç©å®¶å†ç™¼ä¸€å€‹ "SEER_DECIDE"
                // è®“æˆ‘å€‘åšç°¡å–®ä¸€é»ï¼š**è‡ªå‹•ä¿ç•™é»æ•¸è¼ƒå¤§çš„ç‰Œ**ã€‚
                addLog("ğŸ”® é è¨€å®¶è§€æ¸¬æœªä¾†...ä¿ç•™äº†é»æ•¸è¼ƒå¤§çš„ç‰Œ");
                let oldCard = attacker.hand[0];
                if(drawn > oldCard) {
                    attacker.hand = [drawn];
                    // æ”¾å› oldCard
                    gameState.deck.unshift(oldCard); // unshift is start, push is end. Stack model: pop is draw. unshift is bottom.
                } else {
                    gameState.deck.unshift(drawn);
                }
            }
            break;

        case 5: // ä¾å¥³
            attacker.protected = true;
            addLog(`${attacker.name} ç²å¾—ä¾å¥³åº‡è­·`);
            break;
            
        case 6: // ç‹å­
            if(target) {
                discardAndDraw(target);
            }
            break;
            
        case 7: // åœ‹ç‹
            if(target) {
                let temp = attacker.hand;
                attacker.hand = target.hand;
                target.hand = temp;
                addLog(`${attacker.name} èˆ‡ ${target.name} äº¤æ›äº†æ‰‹ç‰Œ`);
            }
            break;
    }
}

function checkAssassinTrigger(holder, guesser) {
    if(holder.hand.includes(1)) {
        addLog(`ğŸ—¡ï¸ ${holder.name} æ˜¯åˆºå®¢ï¼ ${guesser.name} çŒœéŒ¯è¢«åæ®ºï¼`);
        eliminate(guesser);
        // åˆºå®¢æ£„ç‰Œé‡æŠ½
        discardAndDraw(holder, true); // true = isAssassinEffect
    }
}

function discardAndDraw(player, isAssassin = false) {
    if(player.hand.length === 0) return;
    let card = player.hand.pop();
    
    if(card === 9) {
        addLog(`ğŸ˜± ${player.name} è¢«è¿«æ£„æ‰å…¬ä¸»ï¼Œå‡ºå±€ï¼`);
        eliminate(player);
        return;
    }
    
    gameState.discardPile.push({ cardId: card, playerId: player.id });
    addLog(`${player.name} æ£„æ‰äº† ${getCardName(card)} ä¸¦é‡æŠ½`);

    if(!player.out) {
        if(gameState.deck.length > 0) {
            player.hand.push(gameState.deck.pop());
        } else if(gameState.removedCard !== -1) {
            player.hand.push(gameState.removedCard);
            gameState.removedCard = -1;
        } else {
            // ç„¡ç‰Œå¯æŠ½ï¼Œæ‹¿è‘—ç©ºæ‰‹ç‰Œ? é€šå¸¸é€™æ™‚å€™å°±åªæ¯”å¤§å°äº†ï¼Œæˆ–è€…çµ¦ä»–ä¸€å¼µè™›æ“¬ç‰Œ 0
            // è¦å‰‡èªªï¼šè‹¥é‚„æ˜¯ç„¡ç‰Œï¼Œå‰‡å¹³å±€ (é‡å°å…©äºº?)
            // é€™è£¡ç°¡å–®è™•ç†ï¼šå¦‚æœä¸æ­»ï¼Œå°±æ²’æ‰‹ç‰Œï¼Œä¸‹ä¸€è¼ªè‡ªå‹•è¼¸
        }
    }
}

function compareHands(p1, p2, isCupid) {
    let v1 = p1.hand[0] || 0;
    let v2 = p2.hand[0] || 0;
    
    // å…¬ä¸»å¿…å‹
    if(v1 === 9) { eliminate(p2); addLog(`${p1.name} å…¬ä¸»ç™¼å¨ï¼`); return; }
    if(v2 === 9) { eliminate(p1); addLog(`${p2.name} å…¬ä¸»ç™¼å¨ï¼`); return; }

    addLog(`æ¯”è¼ƒï¼š${p1.name}(${v1}) vs ${p2.name}(${v2})`);

    if(isCupid) {
        let g1 = CARDS_DEF[v1].gender;
        let g2 = CARDS_DEF[v2].gender;
        if(g1 === g2) { // åŒæ€§ï¼Œå°çš„å‡ºå±€
            if(v1 < v2) eliminate(p1);
            else if(v2 < v1) eliminate(p2);
        } else { // ç•°æ€§ï¼Œå¤§çš„å‡ºå±€
            if(v1 > v2) eliminate(p1);
            else if(v2 > v1) eliminate(p2);
        }
    } else { // ç”·çˆµï¼Œå°çš„å‡ºå±€
        if(v1 < v2) eliminate(p1);
        else if(v2 < v1) eliminate(p2);
    }
}

function eliminate(player) {
    player.out = true;
    player.hand = []; // æ¸…ç©ºæ‰‹ç‰Œ (æˆ–ä¿ç•™ä½œç‚ºå…¬é–‹è³‡è¨Š)
    addLog(`â˜ ï¸ ${player.name} å‡ºå±€äº†ï¼`);
    checkGameEndInstant();
}

function checkGameEndInstant() {
    let alive = gameState.players.filter(p => !p.out);
    if(alive.length === 1) {
        endGame(alive[0]);
        return true;
    }
    return false;
}

function endGameByScore() {
    let active = gameState.players.filter(p => !p.out);
    let maxVal = -1;
    let winners = [];
    
    active.forEach(p => {
        let val = p.hand[0] || 0;
        if(val > maxVal) {
            maxVal = val;
            winners = [p];
        } else if (val === maxVal) {
            winners.push(p);
        }
    });
    
    endGame(winners);
}

function endGame(winnerOrWinners) {
    gameState.phase = 'GAMEOVER';
    if(Array.isArray(winnerOrWinners)) {
        let names = winnerOrWinners.map(p => p.name).join(" & ");
        gameState.winner = `${names} å…±åŒç²å‹ï¼`;
    } else {
        gameState.winner = `${winnerOrWinners.name} ç²å‹ï¼`;
    }
    broadcastState();
}

function addLog(msg) {
    gameState.logs.unshift(msg);
    if(gameState.logs.length > 20) gameState.logs.pop();
}

function sendPrivateData(peerId, data) {
    if(connections[peerId]) {
        connections[peerId].send(data);
    } else if (peerId === myPeerId) {
        handleClientData(data); // Host is also client
    }
}

function getCardName(id) {
    return CARDS_DEF[id] ? CARDS_DEF[id].name : "??";
}

/* ================= Client UI & Interaction ================= */

function handleClientData(data) {
    if(data.type === 'UPDATE') {
        updateGameUI(data.state);
    } else if (data.type === 'SHOW_HAND') {
        alert(`ç¥çˆ¶å·å·å‘Šè¨´ä½ ï¼š\n${data.targetName} çš„æ‰‹ç‰Œæ˜¯ ã€${getCardName(data.hand[0])}ã€‘`);
    }
}

function updateGameUI(state) {
    // å„²å­˜ç‹€æ…‹
    gameState = state; // Client syncs local gameState
    
    if(state.phase === 'LOBBY') {
        document.getElementById('login-screen').classList.add('hidden');
        document.getElementById('lobby-screen').classList.remove('hidden');
        document.getElementById('game-screen').classList.add('hidden');
        document.getElementById('lobby-room-id').innerText = roomId;
        
        let pList = document.getElementById('lobby-players');
        pList.innerHTML = state.players.map(p => 
            `<div style="text-align:center;">
                <div style="font-size:2.5rem;">${p.avatar}</div>
                <div>${p.name}</div>
             </div>`
        ).join('');

        if(isHost) document.getElementById('host-controls').classList.remove('hidden');
        else document.getElementById('client-wait-msg').classList.remove('hidden');

    } else if (state.phase === 'GAMING') {
        document.getElementById('lobby-screen').classList.add('hidden');
        document.getElementById('game-screen').classList.remove('hidden');
        document.getElementById('gameover-modal').classList.add('hidden');
        
        renderTopBar(state);
        renderOpponents(state);
        renderLogs(state);
        renderMyHand(state);
        renderRefTable(state);
    } else if (state.phase === 'GAMEOVER') {
        document.getElementById('winner-display').innerText = state.winner;
        document.getElementById('gameover-modal').classList.remove('hidden');
    }
}

function renderTopBar(state) {
    document.getElementById('deck-count').innerText = `ç‰Œåº«: ${state.deck.length}`;
    let currentP = state.players[state.turnIndex];
    document.getElementById('turn-indicator').innerText = `å›åˆ: ${currentP.name}`;
    document.getElementById('turn-indicator').style.color = (currentP.id === myPeerId) ? '#eebb44' : '#888';
}

function renderOpponents(state) {
    let container = document.getElementById('opponents-container');
    container.innerHTML = '';
    
    state.players.forEach((p, idx) => {
        if(p.id === myPeerId) return; // ä¸é¡¯ç¤ºè‡ªå·±
        
        let el = document.createElement('div');
        el.className = `player-badge ${idx === state.turnIndex ? 'active-turn' : ''} ${p.out ? 'eliminated' : ''} ${p.protected ? 'protected' : ''}`;
        el.innerHTML = `
            <div style="font-size:2rem;">${p.avatar}</div>
            <div style="font-size:0.8rem; overflow:hidden; text-overflow:ellipsis;">${p.name}</div>
            ${p.out ? 'â˜ ï¸' : (p.connected ? '' : 'ğŸ”Œ')}
            <div class="player-hand-mini">
                ${p.out ? 'âŒ' : (p.hand.length > 0 ? 'ğŸƒ'.repeat(p.hand.length) : '')}
            </div>
            ${p.out && p.hand[0] !== -1 ? `<div style="color:var(--accent)">${getCardName(p.hand[0])}</div>` : ''}
        `;
        container.appendChild(el);
    });
}

function renderLogs(state) {
    let div = document.getElementById('game-log');
    div.innerHTML = state.logs.map(l => `<div class="log-entry">${l}</div>`).join('');
}

function renderMyHand(state) {
    let me = state.players.find(p => p.id === myPeerId);
    if(!me) return;
    
    let container = document.getElementById('my-hand');
    container.innerHTML = '';
    
    let isMyTurn = (state.players[state.turnIndex].id === myPeerId);
    document.getElementById('btn-play').disabled = !isMyTurn || selectedHandIndex === -1;
    document.getElementById('role-indicator').innerText = isMyTurn ? "è¼ªåˆ°ä½ äº†" : "ç­‰å¾…ä¸­...";

    // å¦‚æœå‡ºå±€ï¼Œé¡¯ç¤ºä¸Šå¸è¦–è§’æ‰‹ç‰Œ (ä¾†è‡ª Host çš„å®Œæ•´æ•¸æ“š)
    if(me.out) {
        document.getElementById('btn-play').disabled = true;
        document.getElementById('role-indicator').innerText = "è§€æˆ°ä¸­";
        // é¡¯ç¤ºè§€æˆ°å…§å®¹ï¼Œä¸é¡¯ç¤ºè‡ªå·±çš„æ‰‹ç‰Œ(ç©ºçš„)
        return; 
    }

    me.hand.forEach((cardId, idx) => {
        let def = CARDS_DEF[cardId];
        let el = document.createElement('div');
        el.className = `card ${def.plus ? 'plus' : ''} ${idx === selectedHandIndex ? 'selected' : ''}`;
        el.onclick = () => {
            if(!isMyTurn) return;
            selectedHandIndex = idx;
            renderMyHand(state); // re-render to update selection style
        };
        el.innerHTML = `
            <div class="card-header">
                <span>${def.val}</span>
                <span class="card-gender">${def.gender === 'M' ? 'â™‚' : 'â™€'}</span>
            </div>
            <div class="card-img">${def.icon}</div>
            <div style="font-weight:bold; font-size:0.9rem;">${def.name}</div>
            <div class="card-desc">${def.desc}</div>
        `;
        container.appendChild(el);
    });
}

function renderRefTable(state) {
    let tbody = document.getElementById('ref-table-body');
    let counts = {};
    // Init counts
    for(let k in CARDS_DEF) counts[k] = CARDS_DEF[k].count;
    
    // Subtract discarded
    state.discardPile.forEach(d => {
        if(counts[d.cardId]) counts[d.cardId]--;
    });
    
    tbody.innerHTML = Object.values(CARDS_DEF).map(c => {
        let left = counts[c.id];
        return `<tr class="${left===0 ? 'eliminated-card' : ''}">
            <td>${c.val}</td>
            <td>${c.name}</td>
            <td>${c.gender === 'M' ? 'â™‚' : 'â™€'}</td>
            <td>${left}</td>
        </tr>`;
    }).join('');
}

/* ================= äº’å‹•é‚è¼¯ (Client) ================= */

async function confirmPlayCard() {
    if(selectedHandIndex === -1) return;
    
    // UI Feedback: Progress Bar
    let btn = document.getElementById('btn-play');
    btn.disabled = true;
    let bar = document.getElementById('loading-bar');
    bar.style.display = 'block';
    setTimeout(() => { bar.querySelector('.progress-bar').style.width = '100%'; }, 10);

    let me = gameState.players.find(p => p.id === myPeerId);
    let cardId = me.hand[selectedHandIndex];
    let cardDef = CARDS_DEF[cardId];
    
    let targetId = null;
    let guessId = null;
    
    // åˆ¤æ–·æ˜¯å¦éœ€è¦é¸æ“‡å°è±¡
    let needsTarget = [1, 2, 3, 30, 4, 6, 7].includes(cardId);
    // å°ä¸‘ç‰¹æ®Šåˆ¤å®šï¼šå¦‚æœå°ä¸‘è¤‡è£½äº†ä¸Šé¢çš„ç‰Œï¼Œé€™è£¡å…¶å¯¦åšä¸åˆ°å®Œç¾é æ¸¬ã€‚
    // ç°¡åŒ–ï¼šå¦‚æœæ‰“å‡ºå°ä¸‘ï¼Œä¸”ä¸Šä¸€å¼µæ£„ç‰Œæ˜¯éœ€è¦ Target çš„ï¼Œå‰‡å½ˆå‡º Targetã€‚
    if(cardId === 50 && gameState.discardPile.length > 0) {
        let lastId = gameState.discardPile[gameState.discardPile.length-1].cardId;
        if([1, 2, 3, 30, 4, 6, 7].includes(lastId)) needsTarget = true;
    }

    if(needsTarget) {
        targetId = await promptTarget();
        if(!targetId) { resetUI(); return; } // Cancelled
    }
    
    // åˆ¤æ–·æ˜¯å¦éœ€è¦çŒœç‰Œ (è¡›å…µ 2, å…µé•· 20)
    let needsGuess = (cardId === 2 || cardId === 20);
    // å°ä¸‘
    if(cardId === 50 && gameState.discardPile.length > 0) {
        let lastId = gameState.discardPile[gameState.discardPile.length-1].cardId;
        if(lastId === 2 || lastId === 20) needsGuess = true;
    }

    if(needsGuess) {
        guessId = await promptGuess();
        if(!guessId) { resetUI(); return; }
    }
    
    // ç™¼é€å‹•ä½œ
    sendAction({ cardId, targetId, guessId });
    selectedHandIndex = -1;
    resetUI();
}

function sendAction(payload) {
    if(isHost) {
        processGameAction(myPeerId, payload);
    } else {
        conn.send({ type: 'ACTION', payload });
    }
}

function resetUI() {
    let bar = document.getElementById('loading-bar');
    bar.style.display = 'none';
    bar.querySelector('.progress-bar').style.width = '0%';
}

/* ================= é¸æ“‡å™¨ Modal ================= */

function promptTarget() {
    return new Promise(resolve => {
        let modal = document.getElementById('selector-modal');
        let container = document.getElementById('selector-options');
        document.getElementById('selector-title').innerText = "é¸æ“‡ç›®æ¨™";
        container.innerHTML = '';
        
        let validTargets = gameState.players.filter(p => !p.out && !p.protected && p.id !== myPeerId);
        // ç‹å­å¯ä»¥æŒ‡è‡ªå·±
        let cardId = gameState.players.find(p => p.id === myPeerId).hand[selectedHandIndex];
        if(cardId === 6) validTargets.push(gameState.players.find(p => p.id === myPeerId));
        
        if(validTargets.length === 0) {
            alert("ç„¡æœ‰æ•ˆç›®æ¨™ï¼Œå¡ç‰Œå°‡ç„¡æ•ˆæ‰“å‡º");
            modal.classList.add('hidden');
            resolve(null); // Server side handles null target as discard without effect
            return;
        }

        validTargets.forEach(p => {
            let btn = document.createElement('div');
            btn.className = 'btn';
            btn.innerHTML = `${p.avatar} ${p.name}`;
            btn.onclick = () => {
                modal.classList.add('hidden');
                resolve(p.id);
            };
            container.appendChild(btn);
        });
        
        // Cancel btn
        let cancel = document.getElementById('selector-cancel');
        cancel.classList.remove('hidden');
        cancel.onclick = () => { modal.classList.add('hidden'); resolve(null); };

        modal.classList.remove('hidden');
    });
}

function promptGuess() {
    return new Promise(resolve => {
        let modal = document.getElementById('selector-modal');
        let container = document.getElementById('selector-options');
        document.getElementById('selector-title').innerText = "çŒœæ¸¬èº«åˆ†";
        container.innerHTML = '';
        
        // ä¸èƒ½çŒœè¡›å…µ(2)
        Object.values(CARDS_DEF).forEach(c => {
            if(c.id === 2 || c.id === 20) return; // Cannot guess Guard
            if(c.plus && ![20,30,40,50].includes(c.id)) return; // logic check

            let btn = document.createElement('div');
            btn.className = 'btn';
            btn.style.width = '80px';
            btn.innerHTML = `${c.val} ${c.name}`;
            btn.onclick = () => {
                modal.classList.add('hidden');
                resolve(c.id);
            };
            container.appendChild(btn);
        });
         
        let cancel = document.getElementById('selector-cancel');
        cancel.classList.remove('hidden');
        cancel.onclick = () => { modal.classList.add('hidden'); resolve(null); };

        modal.classList.remove('hidden');
    });
}

function closeSelector() {
    document.getElementById('selector-modal').classList.add('hidden');
}

/* ================= è¼”åŠ©åŠŸèƒ½ ================= */
function randomizeAvatar() {
    let idx = Math.floor(Math.random() * AVATARS.length);
    myAvatar = AVATARS[idx];
    document.getElementById('avatar-display').innerText = myAvatar;
}
function validateInput() {
    let name = document.getElementById('username').value.trim();
    if(!name) { alert("è«‹è¼¸å…¥æš±ç¨±"); return false; }
    myName = name;
    localStorage.setItem('ll_name', myName);
    localStorage.setItem('ll_avatar', myAvatar);
    return true;
}
function copyRoomId() {
    navigator.clipboard.writeText(roomId);
    alert("å·²è¤‡è£½: " + roomId);
}
function toggleRef() {
    document.getElementById('ref-modal').classList.toggle('hidden');
}
function attemptRejoin() {
    let lastHost = localStorage.getItem('ll_last_host');
    if(!lastHost) return alert("ç„¡ä¸Šæ¬¡é€£ç·šç´€éŒ„");
    document.getElementById('room-id-input').value = lastHost;
    joinGame();
}
function returnToLobby() {
    if(isHost) {
        gameState.phase = 'LOBBY';
        gameState.players.forEach(p => { p.hand = []; p.out = false; p.protected = false; });
        gameState.deck = [];
        gameState.discardPile = [];
        gameState.logs = [];
        broadcastState();
    }
    // Client waits for update
}
function uiShowStatus(msg) {
    document.getElementById('status-msg').innerText = msg;
}

// Init
randomizeAvatar();
if(myName) document.getElementById('username').value = myName;

</script>
</body>
</html>
